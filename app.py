import os
import click
from datetime import date, datetime
from flask import Flask, jsonify, request, render_template
from flask.cli import with_appcontext
from json import JSONEncoder
import psycopg2
import psycopg2.extras

# Python의 날짜/시간 객체를 JSON이 이해하는 문자열로 변환하는 클래스
class CustomJSONEncoder(JSONEncoder):
    def default(self, obj):
        try:
            if isinstance(obj, (date, datetime)):
                return obj.isoformat()
            iterable = iter(obj)
        except TypeError:
            pass
        else:
            return list(iterable)
        return JSONEncoder.default(self, obj)

app = Flask(__name__)
# 앱에 위에서 만든 커스텀 변환기를 사용하도록 등록
app.json_encoder = CustomJSONEncoder

# --- 데이터베이스 연결 및 초기화 ---

def get_db_connection():
    """PostgreSQL 데이터베이스에 연결합니다."""
    dsn = os.environ.get("DATABASE_URL")
    if not dsn:
        raise RuntimeError("DATABASE_URL 환경변수가 설정되어 있지 않습니다.")
    return psycopg2.connect(dsn, cursor_factory=psycopg2.extras.RealDictCursor)

def init_db():
    """데이터베이스 테이블을 생성하고 초기 데이터를 삽입합니다."""
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            # 기존 테이블들을 삭제하여 초기화
            cur.execute("DROP TABLE IF EXISTS PostReadStatus, Posts, Comments, Tasks, Projects, Users CASCADE;")
            
            # 테이블 생성
            cur.execute("""
                CREATE TABLE Users (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE
                );
            """)
            cur.execute("""
                CREATE TABLE Projects (
                 id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  user_id INTEGER REFERENCES Users(id) ON DELETE SET NULL,
                  start_date DATE NOT NULL,
                 deadline DATE, -- [수정] NOT NULL 제거
                 priority INTEGER DEFAULT 2,
                 progress INTEGER DEFAULT 0,
                    status TEXT NOT NULL DEFAULT 'scheduled', -- [수정] 기본값을 'scheduled'로 변경
                 category TEXT NOT NULL DEFAULT '기타', -- [신규] 카테고리 컬럼 추가
                 FOREIGN KEY (user_id) REFERENCES Users(id)
                  );
            """)
            cur.execute("""
                CREATE TABLE Tasks (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    content TEXT NOT NULL,
                    deadline DATE,
                    progress INTEGER DEFAULT 0,
                    is_current INTEGER DEFAULT 0
                );
            """)
            cur.execute("""
                CREATE TABLE Comments (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    author_name TEXT NOT NULL,
                    content TEXT NOT NULL,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE Posts (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE PostReadStatus (
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    post_id INTEGER NOT NULL REFERENCES Posts(id) ON DELETE CASCADE,
                    read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    PRIMARY KEY (user_id, post_id)
                );
            """)

            # 초기 사용자 데이터 삽입
            users = [('이재욱',), ('안호형',), ('안예준',), ('DI 팀',)]
            psycopg2.extras.execute_batch(cur, "INSERT INTO Users(name) VALUES (%s) ON CONFLICT (name) DO NOTHING", users)
            print("Database initialized.")
    finally:
        conn.close()

@click.command('init-db')
@with_appcontext
def init_db_command():
    init_db()
    click.echo('Initialized the database.')

app.cli.add_command(init_db_command)

# --- 뷰 ---
@app.route('/')
def index():
    return render_template('index.html')

# --- 유틸 ---
def _parse_date(val):
    if not val: return None
    try:
        return date.fromisoformat(val)
    except (TypeError, ValueError):
        return val

# --- API 라우트 ---

@app.route('/api/data', methods=['GET'])
def get_all_data():
    """앱에 필요한 모든 데이터를 효율적으로 조회합니다."""
    current_user_id = request.headers.get('X-Current-User-ID')
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            # 1. 모든 데이터를 각각 한 번씩만 조회
            cur.execute("SELECT * FROM Projects ORDER BY status, priority, deadline ASC")
            projects = cur.fetchall()
            cur.execute("SELECT * FROM Tasks ORDER BY id ASC")
            tasks = cur.fetchall()
            cur.execute("SELECT * FROM Comments ORDER BY created_at ASC")
            comments = cur.fetchall()
            cur.execute("SELECT * FROM Users ORDER BY id ASC")
            users = cur.fetchall()
            cur.execute("SELECT p.*, u.name AS author_name FROM Posts p JOIN Users u ON u.id=p.user_id ORDER BY p.created_at DESC")
            posts = cur.fetchall()

            # 2. 파이썬에서 데이터 조합
            tasks_by_project = {}
            for task in tasks:
                pid = task['project_id']
                tasks_by_project.setdefault(pid, []).append(task)
            
            comments_by_project = {}
            for comment in comments:
                pid = comment['project_id']
                comments_by_project.setdefault(pid, []).append(comment)

            for proj in projects:
                proj['tasks'] = tasks_by_project.get(proj['id'], [])
                proj['comments'] = comments_by_project.get(proj['id'], [])
            
            # 3. 새 글 알림 여부 계산
            has_new = False
            if current_user_id:
                try:
                    uid = int(current_user_id)
                    cur.execute("""
                        SELECT EXISTS(
                            SELECT 1 FROM Posts p WHERE p.user_id != %s AND NOT EXISTS 
                            (SELECT 1 FROM PostReadStatus r WHERE r.post_id = p.id AND r.user_id = %s)
                        ) AS has_new
                    """, (uid, uid))
                    has_new = cur.fetchone()['has_new']
                except (ValueError, TypeError):
                    has_new = False

            return jsonify({
                'projects': projects,
                'users': users,
                'posts': posts,
                'has_new_posts': bool(has_new)
            })
    finally:
        conn.close()

# --- Users ---
@app.route('/api/user', methods=['POST'])
def create_user():
    name = (request.get_json() or {}).get('name')
    if not name:
        return jsonify({'status': 'error', 'message': 'name is required'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Users(name) VALUES (%s) ON CONFLICT (name) DO NOTHING RETURNING *", (name,))
            new_user = cur.fetchone()
        return jsonify(new_user), 201
    finally:
        conn.close()

@app.route('/api/user/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Projects SET user_id=NULL WHERE user_id=%s", (user_id,))
            cur.execute("DELETE FROM Users WHERE id=%s", (user_id,))
        return jsonify({'status': 'success'})
    finally:
        conn.close()

# --- Projects ---
@app.route('/api/project', methods=['POST'])
def create_project():
    data = request.get_json() or {}
    # [수정] category, status 필드 추가
    required = ['name', 'user_id', 'start_date', 'priority', 'category', 'status']
    if any(k not in data for k in required):
        return jsonify({'status': 'error', 'message': '필수 정보가 누락되었습니다.'}), 400
    
    # [수정] '진행중' 상태일 때만 마감일이 필수
    if data['status'] == 'active' and not data.get('deadline'):
        return jsonify({'status': 'error', 'message': '진행중인 프로젝트는 마감일이 필수입니다.'}), 400

    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "INSERT INTO Projects (name, user_id, start_date, deadline, priority, category, status) VALUES (%s,%s,%s,%s,%s,%s,%s) RETURNING id",
                (data['name'], data['user_id'], _parse_date(data['start_date']), _parse_date(data.get('deadline')), data['priority'], data['category'], data['status'])
            )
            project_id = cur.fetchone()['id']
            tasks = data.get('tasks') or []
            if tasks:
                rows = [(project_id, t['content'], _parse_date(t.get('deadline'))) for t in tasks if t.get('content')]
                if rows:
                    psycopg2.extras.execute_batch(cur, "INSERT INTO Tasks (project_id, content, deadline) VALUES (%s,%s,%s)", rows)
            
            cur.execute("SELECT * FROM Projects WHERE id = %s", (project_id,))
            new_project = cur.fetchone()
            new_project['tasks'] = []
            new_project['comments'] = []
        return jsonify(new_project), 201
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['PUT'])
def update_project(project_id):
    data = request.get_json() or {}
    fields, params = [], []
    # [수정] category, status 업데이트 가능하도록 추가
    for key in ('name','priority','progress', 'deadline', 'category', 'status'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key == 'deadline': val = _parse_date(val)
            params.append(val)
    
    
    if not fields:
        return jsonify({'status': 'error', 'message': '수정할 값이 없습니다.'}), 400
    
    params.append(project_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Projects SET {', '.join(fields)} WHERE id=%s", tuple(params))
            cur.execute("SELECT * FROM Projects WHERE id = %s", (project_id,))
            updated_project = cur.fetchone()
        return jsonify(updated_project)
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>/status', methods=['PUT'])
def set_project_status(project_id):
    status = (request.get_json() or {}).get('status')
    if status not in ('active','completed'):
        return jsonify({'status':'error','message':'잘못된 상태값입니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Projects SET status=%s WHERE id=%s", (status, project_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['DELETE'])
def delete_project(project_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Projects WHERE id=%s", (project_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Tasks ---
@app.route('/api/project/<int:project_id>/task', methods=['POST'])
def create_task(project_id):
    content = (request.get_json() or {}).get('content', '')
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Tasks (project_id, content) VALUES (%s,%s) RETURNING *", (project_id, content))
            new_task = cur.fetchone()
        return jsonify(new_task), 201
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    data = request.get_json() or {}
    fields, params = [], []
    for key in ('content','deadline','progress'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key == 'deadline': val = _parse_date(val)
            params.append(val)

    if not fields:
        return jsonify({'status': 'error', 'message':'수정할 값이 없습니다.'}), 400
    
    params.append(task_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Tasks SET {', '.join(fields)} WHERE id=%s", tuple(params))
            cur.execute("SELECT * FROM Tasks WHERE id = %s", (task_id,))
            updated_task = cur.fetchone()
        return jsonify(updated_task)
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Tasks WHERE id=%s", (task_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Comments ---
@app.route('/api/project/<int:project_id>/comment', methods=['POST'])
def create_comment(project_id):
    data = request.get_json() or {}
    author_name = data.get('author_name')
    content = data.get('content')
    if not author_name or not content:
        return jsonify({'status':'error','message':'author_name, content 필수'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Comments (project_id, author_name, content) VALUES (%s,%s,%s) RETURNING *", (project_id, author_name, content))
            new_comment = cur.fetchone()
        return jsonify(new_comment), 201
    finally:
        conn.close()

@app.route('/api/comment/<int:comment_id>', methods=['DELETE'])
def delete_comment(comment_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Comments WHERE id=%s", (comment_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Posts / 게시판 ---
@app.route('/api/post', methods=['POST'])
def create_post():
    data = request.get_json() or {}
    required = ['title','content','user_id']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Posts (title, content, user_id) VALUES (%s,%s,%s) RETURNING id", (data['title'], data['content'], data['user_id']))
            post_id = cur.fetchone()['id']
            cur.execute("INSERT INTO PostReadStatus (user_id, post_id) VALUES (%s,%s) ON CONFLICT DO NOTHING", (data['user_id'], post_id))
            
            cur.execute("SELECT p.*, u.name as author_name FROM Posts p JOIN Users u ON p.user_id = u.id WHERE p.id = %s", (post_id,))
            new_post = cur.fetchone()
        return jsonify(new_post), 201
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['PUT'])
def update_post(post_id):
    data = request.get_json() or {}
    required = ['title','content']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Posts SET title=%s, content=%s, updated_at=NOW() WHERE id=%s", (data['title'], data['content'], post_id))
            cur.execute("SELECT p.*, u.name as author_name FROM Posts p JOIN Users u ON p.user_id = u.id WHERE p.id = %s", (post_id,))
            updated_post = cur.fetchone()
        return jsonify(updated_post)
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['DELETE'])
def delete_post(post_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Posts WHERE id=%s", (post_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/posts/mark-as-read', methods=['POST'])
def mark_posts_as_read():
    user_id = (request.get_json() or {}).get('user_id')
    if not user_id:
        return jsonify({'status':'error','message':'user_id is required'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("""
                INSERT INTO PostReadStatus (user_id, post_id)
                SELECT %s, p.id FROM Posts p
                WHERE NOT EXISTS (
                    SELECT 1 FROM PostReadStatus r WHERE r.post_id = p.id AND r.user_id = %s
                )
            """, (user_id, user_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

if __name__ == '__main__':
    app.run(debug=True)