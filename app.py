
import os
import click
from datetime import datetime
from flask import Flask, jsonify, request, render_template
from flask.cli import with_appcontext
import psycopg2
import psycopg2.extras

app = Flask(__name__)

# --- 데이터베이스 연결 및 초기화 (Postgres) ---

def get_db_connection():
    """PostgreSQL에 연결하고, 모든 결과를 dict로 반환하도록 설정합니다."""
    dsn = os.environ.get("DATABASE_URL")
    if not dsn:
        raise RuntimeError("DATABASE_URL 환경변수가 설정되어 있지 않습니다.")
    # RealDictCursor -> dict rows
    return psycopg2.connect(dsn, cursor_factory=psycopg2.extras.RealDictCursor)

def init_db():
    """데이터베이스 스키마 생성 및 초기 사용자 추가"""
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            # 테이블 생성
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Users (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Projects (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL,
                    user_id INTEGER REFERENCES Users(id) ON DELETE SET NULL,
                    start_date DATE NOT NULL,
                    deadline DATE NOT NULL,
                    priority INTEGER DEFAULT 2,
                    progress INTEGER DEFAULT 0,
                    status TEXT NOT NULL DEFAULT 'active'
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Tasks (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    content TEXT NOT NULL,
                    deadline DATE,
                    progress INTEGER DEFAULT 0,
                    is_current INTEGER DEFAULT 0
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Comments (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    author_name TEXT NOT NULL,
                    content TEXT NOT NULL,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Posts (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS PostReadStatus (
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    post_id INTEGER NOT NULL REFERENCES Posts(id) ON DELETE CASCADE,
                    read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    PRIMARY KEY (user_id, post_id)
                );
            """)
            # 초기 사용자
            users = [('이재욱',), ('안호형',), ('안예준',), ('DI 팀',)]
            for (name,) in users:
                cur.execute("INSERT INTO Users(name) VALUES (%s) ON CONFLICT (name) DO NOTHING", (name,))
    finally:
        conn.close()

@click.command('init-db')
@with_appcontext
def init_db_command():
    """터미널에서 'flask init-db'로 테이블 생성/초기 사용자 추가"""
    init_db()
    click.echo('Initialized the database.')

app.cli.add_command(init_db_command)

# --- 뷰 ---
@app.route('/')
def index():
    # 프로젝트 루트에 index.html이 있는 구성이라면, Flask 템플릿 경로에 맞게 파일을 이동하세요.
    # 기존 프로젝트 구조를 유지하기 위해 원래 코드대로 둡니다.
    return render_template('index.html')

# --- 유틸 ---

def _parse_date(val):
    if val is None or val == '':
        return None
    # YYYY-MM-DD 또는 ISO8601 일부 허용
    try:
        return datetime.fromisoformat(val).date()
    except Exception:
        # 그대로 문자열을 DATE에 넣도록 반환 (psycopg2가 캐스팅 시도)
        return val

# --- API 라우트 ---

@app.route('/api/data', methods=['GET'])
def get_all_data():
    current_user_id = request.headers.get('X-Current-User-ID')
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            # Projects
            cur.execute("SELECT * FROM Projects ORDER BY status, priority, deadline ASC")
            projects = cur.fetchall()

            # For each project, include tasks & comments
            for proj in projects:
                pid = proj['id']
                cur.execute("SELECT * FROM Tasks WHERE project_id=%s ORDER BY id ASC", (pid,))
                proj['tasks'] = cur.fetchall()
                cur.execute("SELECT * FROM Comments WHERE project_id=%s ORDER BY created_at ASC", (pid,))
                proj['comments'] = cur.fetchall()

            # Users
            cur.execute("SELECT * FROM Users ORDER BY id ASC")
            users = cur.fetchall()

            # Posts (최신이 위)
            cur.execute("SELECT p.*, u.name AS author_name FROM Posts p JOIN Users u ON u.id=p.user_id ORDER BY p.created_at DESC")
            posts = cur.fetchall()

            # has_new_posts for current user
            has_new = False
            if current_user_id:
                try:
                    uid = int(current_user_id)
                    cur.execute("""
                        SELECT EXISTS(
                            SELECT 1
                            FROM Posts p
                            LEFT JOIN PostReadStatus r
                              ON r.post_id = p.id AND r.user_id = %s
                            WHERE r.post_id IS NULL
                            LIMIT 1
                        ) AS has_new
                    """, (uid,))
                    has_new = cur.fetchone()['has_new']
                except Exception:
                    has_new = False

        return jsonify({
            'projects': projects,
            'users': users,
            'posts': posts,
            'has_new_posts': bool(has_new)
        })
    finally:
        conn.close()

# --- Users ---
@app.route('/api/user', methods=['POST'])
def create_user():
    data = request.get_json() or {}
    name = data.get('name')
    if not name:
        return jsonify({'status': 'error', 'message': 'name is required'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Users(name) VALUES (%s) RETURNING id", (name,))
            new_id = cur.fetchone()['id']
        return jsonify({'status': 'success', 'id': new_id}), 201
    finally:
        conn.close()

@app.route('/api/user/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Users WHERE id=%s", (user_id,))
        return jsonify({'status': 'success'})
    finally:
        conn.close()

# --- Projects ---
@app.route('/api/project', methods=['POST'])
def create_project():
    data = request.get_json() or {}
    required = ['name', 'user_id', 'start_date', 'deadline', 'priority']
    if any(k not in data for k in required):
        return jsonify({'status': 'error', 'message': '필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "INSERT INTO Projects (name, user_id, start_date, deadline, priority) VALUES (%s,%s,%s,%s,%s) RETURNING id",
                (data['name'], data['user_id'], _parse_date(data['start_date']), _parse_date(data['deadline']), data['priority'])
            )
            project_id = cur.fetchone()['id']
            tasks = data.get('tasks') or []
            if tasks:
                rows = [(project_id, t['content'], _parse_date(t.get('deadline'))) for t in tasks]
                psycopg2.extras.execute_batch(cur,
                    "INSERT INTO Tasks (project_id, content, deadline) VALUES (%s,%s,%s)", rows)
        return jsonify({'status': 'success', 'id': project_id}), 201
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['PUT'])
def update_project(project_id):
    data = request.get_json() or {}
    fields = []
    params = []
    for key in ('name','user_id','start_date','deadline','priority','progress','status'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key in ('start_date','deadline'):
                val = _parse_date(val)
            params.append(val)
    if not fields:
        return jsonify({'status': 'error', 'message': '수정할 값이 없습니다.'}), 400
    params.append(project_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Projects SET {', '.join(fields)} WHERE id=%s", tuple(params))
        return jsonify({'status': 'success'})
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>/status', methods=['PUT'])
def set_project_status(project_id):
    data = request.get_json() or {}
    status = data.get('status')
    if status not in ('active','completed'):
        return jsonify({'status':'error','message':'status must be active or completed'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Projects SET status=%s WHERE id=%s", (status, project_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['DELETE'])
def delete_project(project_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Projects WHERE id=%s", (project_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Tasks ---
@app.route('/api/project/<int:project_id>/task', methods=['POST'])
def create_task(project_id):
    data = request.get_json() or {}
    content = data.get('content')
    if not content:
        return jsonify({'status':'error','message':'content is required'}), 400
    deadline = _parse_date(data.get('deadline'))
    progress = int(data.get('progress', 0))
    is_current = int(data.get('is_current', 0))
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "INSERT INTO Tasks (project_id, content, deadline, progress, is_current) VALUES (%s,%s,%s,%s,%s) RETURNING id",
                (project_id, content, deadline, progress, is_current)
            )
            task_id = cur.fetchone()['id']
        return jsonify({'status': 'success', 'id': task_id}), 201
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    data = request.get_json() or {}
    fields = []
    params = []
    for key in ('content','deadline','progress','is_current','project_id'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key == 'deadline':
                val = _parse_date(val)
            params.append(val)
    if not fields:
        return jsonify({'status': 'error', 'message':'수정할 값이 없습니다.'}), 400
    params.append(task_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Tasks SET {', '.join(fields)} WHERE id=%s", tuple(params))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Tasks WHERE id=%s", (task_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Comments ---
@app.route('/api/project/<int:project_id>/comment', methods=['POST'])
def create_comment(project_id):
    data = request.get_json() or {}
    author_name = data.get('author_name')
    content = data.get('content')
    if not author_name or not content:
        return jsonify({'status':'error','message':'author_name, content 필수'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "INSERT INTO Comments (project_id, author_name, content) VALUES (%s,%s,%s) RETURNING id",
                (project_id, author_name, content)
            )
            cid = cur.fetchone()['id']
        return jsonify({'status': 'success', 'id': cid}), 201
    finally:
        conn.close()

@app.route('/api/comment/<int:comment_id>', methods=['PUT'])
def update_comment(comment_id):
    data = request.get_json() or {}
    fields = []
    params = []
    for key in ('author_name','content'):
        if key in data:
            fields.append(f"{key}=%s")
            params.append(data[key])
    if not fields:
        return jsonify({'status':'error','message':'수정할 값이 없습니다.'}), 400
    params.append(comment_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Comments SET {', '.join(fields)} WHERE id=%s", tuple(params))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/comment/<int:comment_id>', methods=['DELETE'])
def delete_comment(comment_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Comments WHERE id=%s", (comment_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# --- Posts / 게시판 ---
@app.route('/api/post', methods=['POST'])
def create_post():
    data = request.get_json() or {}
    required = ['title','content','user_id']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "INSERT INTO Posts (title, content, user_id) VALUES (%s,%s,%s) RETURNING id",
                (data['title'], data['content'], data['user_id'])
            )
            post_id = cur.fetchone()['id']
            # 작성자 본인을 읽음 처리
            cur.execute(
                "INSERT INTO PostReadStatus (user_id, post_id) VALUES (%s,%s) ON CONFLICT DO NOTHING",
                (data['user_id'], post_id)
            )
        return jsonify({'status':'success','id':post_id}), 201
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['PUT'])
def update_post(post_id):
    data = request.get_json() or {}
    required = ['title','content']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(
                "UPDATE Posts SET title=%s, content=%s, updated_at=NOW() WHERE id=%s",
                (data['title'], data['content'], post_id)
            )
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['DELETE'])
def delete_post(post_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Posts WHERE id=%s", (post_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/posts/mark-as-read', methods=['POST'])
def mark_posts_as_read():
    data = request.get_json() or {}
    user_id = data.get('user_id')
    if not user_id:
        return jsonify({'status':'error','message':'user_id is required'}), 400

    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            # 아직 읽지 않은 게시글들에 대해 읽음 처리
            cur.execute("""
                INSERT INTO PostReadStatus (user_id, post_id)
                SELECT %s, p.id
                FROM Posts p
                LEFT JOIN PostReadStatus r
                  ON r.post_id = p.id AND r.user_id = %s
                WHERE r.post_id IS NULL
            """, (user_id, user_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

if __name__ == '__main__':
    app.run(debug=True)
