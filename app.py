import os
import click
from datetime import date, datetime
from flask import Flask, jsonify, request, render_template
from flask.cli import with_appcontext
from json import JSONEncoder
import psycopg2
import psycopg2.extras

# =================================
# 1. 앱 설정 및 데이터베이스 초기화
# =================================

class CustomJSONEncoder(JSONEncoder):
    def default(self, obj):
        try:
            if isinstance(obj, (date, datetime)):
                return obj.isoformat()
            iterable = iter(obj)
        except TypeError:
            pass
        else:
            return list(iterable)
        return JSONEncoder.default(self, obj)

app = Flask(__name__)
app.json_encoder = CustomJSONEncoder

def get_db_connection():
    dsn = os.environ.get("DATABASE_URL")
    if not dsn:
        raise RuntimeError("DATABASE_URL 환경변수가 설정되어 있지 않습니다.")
    return psycopg2.connect(dsn, cursor_factory=psycopg2.extras.RealDictCursor)

def init_db():
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DROP TABLE IF EXISTS PostReadStatus, Posts, Comments, Tasks, Projects, Users CASCADE;")
            
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Users (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Projects (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL,
                    user_id INTEGER REFERENCES Users(id) ON DELETE SET NULL,
                    start_date DATE NOT NULL,
                    deadline DATE,
                    priority INTEGER DEFAULT 2,
                    progress INTEGER DEFAULT 0,
                    status TEXT NOT NULL DEFAULT 'scheduled',
                    category TEXT NOT NULL DEFAULT '기타'
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Tasks (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    content TEXT NOT NULL,
                    deadline DATE,
                    progress INTEGER DEFAULT 0,
                    is_current INTEGER DEFAULT 0,
                    task_order INTEGER DEFAULT 0
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Comments (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    project_id INTEGER NOT NULL REFERENCES Projects(id) ON DELETE CASCADE,
                    author_name TEXT NOT NULL,
                    content TEXT NOT NULL,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS Posts (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                );
            """)
            cur.execute("""
                CREATE TABLE IF NOT EXISTS PostReadStatus (
                    user_id INTEGER NOT NULL REFERENCES Users(id) ON DELETE CASCADE,
                    post_id INTEGER NOT NULL REFERENCES Posts(id) ON DELETE CASCADE,
                    read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                    PRIMARY KEY (user_id, post_id)
                );
            """)

            users = [('이재욱',), ('안호형',), ('안예준',), ('DI 팀',)]
            psycopg2.extras.execute_batch(cur, "INSERT INTO Users(name) VALUES (%s) ON CONFLICT (name) DO NOTHING", users)
            print("Database initialized.")
    finally:
        conn.close()

@click.command('init-db')
@with_appcontext
def init_db_command():
    init_db()
    click.echo('Initialized the database.')

app.cli.add_command(init_db_command)

# --- 유틸리티 함수 ---
def _parse_date(val):
    if not val: return None
    try:
        return date.fromisoformat(val)
    except (TypeError, ValueError):
        return val

# =================================
# 2. 메인 뷰 및 데이터 조회 API
# =================================

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/data', methods=['GET'])
def get_all_data():
    current_user_id = request.headers.get('X-Current-User-ID')
    conn = get_db_connection()
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT * FROM Projects ORDER BY status, priority, deadline ASC")
            projects = cur.fetchall()
            cur.execute("SELECT * FROM Tasks ORDER BY task_order ASC")
            tasks = cur.fetchall()
            cur.execute("SELECT * FROM Comments ORDER BY created_at ASC")
            comments = cur.fetchall()
            cur.execute("SELECT * FROM Users ORDER BY id ASC")
            users = cur.fetchall()
            cur.execute("SELECT p.*, u.name AS author_name FROM Posts p JOIN Users u ON u.id=p.user_id ORDER BY p.created_at DESC")
            posts = cur.fetchall()

            tasks_by_project = {p['id']: [] for p in projects}
            for task in tasks:
                tasks_by_project.get(task['project_id'], []).append(task)
            
            comments_by_project = {p['id']: [] for p in projects}
            for comment in comments:
                comments_by_project.get(comment['project_id'], []).append(comment)

            for proj in projects:
                proj['tasks'] = tasks_by_project.get(proj['id'], [])
                proj['comments'] = comments_by_project.get(proj['id'], [])
            
            has_new = False
            if current_user_id:
                try:
                    uid = int(current_user_id)
                    cur.execute("""
                        SELECT EXISTS(
                            SELECT 1 FROM Posts p WHERE p.user_id != %s AND NOT EXISTS 
                            (SELECT 1 FROM PostReadStatus r WHERE r.post_id = p.id AND r.user_id = %s)
                        ) AS has_new
                    """, (uid, uid))
                    has_new = cur.fetchone()['has_new']
                except (ValueError, TypeError):
                    has_new = False

            return jsonify({
                'projects': projects,
                'users': users,
                'posts': posts,
                'has_new_posts': bool(has_new)
            })
    finally:
        conn.close()

# =================================
# 3. 사용자 (Users) API
# =================================

@app.route('/api/user', methods=['POST'])
def create_user():
    name = (request.get_json() or {}).get('name')
    if not name:
        return jsonify({'status': 'error', 'message': 'name is required'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Users(name) VALUES (%s) ON CONFLICT (name) DO NOTHING RETURNING *", (name,))
            new_user = cur.fetchone()
        return jsonify(new_user), 201
    finally:
        conn.close()

@app.route('/api/user/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Projects SET user_id=NULL WHERE user_id=%s", (user_id,))
            cur.execute("DELETE FROM Users WHERE id=%s", (user_id,))
        return jsonify({'status': 'success'})
    finally:
        conn.close()

# =================================
# 4. 프로젝트 (Projects) API
# =================================

@app.route('/api/project', methods=['POST'])
def create_project():
    data = request.get_json() or {}
    required = ['name', 'user_id', 'start_date', 'priority', 'category', 'status']
    if any(k not in data for k in required):
        return jsonify({'status': 'error', 'message': '필수 정보가 누락되었습니다.'}), 400
    if data['status'] == 'active' and not data.get('deadline'):
        return jsonify({'status': 'error', 'message': '진행중인 프로젝트는 마감일이 필수입니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Projects (name, user_id, start_date, deadline, priority, category, status) VALUES (%s,%s,%s,%s,%s,%s,%s) RETURNING id", (data['name'], data['user_id'], _parse_date(data['start_date']), _parse_date(data.get('deadline')), data['priority'], data['category'], data['status']))
            project_id = cur.fetchone()['id']
            tasks = data.get('tasks') or []
            if tasks:
                rows = [(project_id, t['content'], _parse_date(t.get('deadline')), i + 1) for i, t in enumerate(tasks) if t.get('content')]
                if rows:
                    psycopg2.extras.execute_batch(cur, "INSERT INTO Tasks (project_id, content, deadline, task_order) VALUES (%s,%s,%s,%s)", rows)
            cur.execute("SELECT * FROM Projects WHERE id = %s", (project_id,))
            new_project = cur.fetchone()
            cur.execute("SELECT * FROM Tasks WHERE project_id = %s ORDER BY task_order ASC", (project_id,))
            new_tasks = cur.fetchall()
            new_project['tasks'] = new_tasks
            new_project['comments'] = []
        return jsonify(new_project), 201
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['PUT'])
def update_project(project_id):
    data = request.get_json() or {}
    fields, params = [], []
    for key in ('name', 'priority', 'progress', 'deadline', 'category', 'user_id'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key == 'deadline': val = _parse_date(val)
            params.append(val)
    if not fields:
        return jsonify({'status': 'error', 'message': '수정할 값이 없습니다.'}), 400
    params.append(project_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Projects SET {', '.join(fields)} WHERE id=%s", tuple(params))
            cur.execute("SELECT * FROM Projects WHERE id = %s", (project_id,))
            updated_project = cur.fetchone()
            if updated_project:
                cur.execute("SELECT * FROM Tasks WHERE project_id = %s ORDER BY task_order ASC", (project_id,))
                tasks = cur.fetchall()
                cur.execute("SELECT * FROM Comments WHERE project_id = %s ORDER BY created_at ASC", (project_id,))
                comments = cur.fetchall()
                updated_project['tasks'] = tasks
                updated_project['comments'] = comments
        return jsonify(updated_project)
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>/status', methods=['PUT'])
def set_project_status(project_id):
    status = (request.get_json() or {}).get('status')
    if status not in ('active','completed', 'scheduled'):
        return jsonify({'status':'error','message':'잘못된 상태값입니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Projects SET status=%s WHERE id=%s", (status, project_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/project/<int:project_id>', methods=['DELETE'])
def delete_project(project_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Projects WHERE id=%s", (project_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# =================================
# 5. 세부 업무 (Tasks) API
# =================================

@app.route('/api/project/<int:project_id>/task', methods=['POST'])
def create_task(project_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("SELECT COALESCE(MAX(task_order), 0) + 1 AS new_order FROM Tasks WHERE project_id = %s", (project_id,))
            new_order = cur.fetchone()['new_order']
            cur.execute("INSERT INTO Tasks (project_id, content, task_order) VALUES (%s,%s,%s) RETURNING *", (project_id, '', new_order))
            new_task = cur.fetchone()
        return jsonify(new_task), 201
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    data = request.get_json() or {}
    fields, params = [], []
    for key in ('content','deadline','progress'):
        if key in data:
            fields.append(f"{key}=%s")
            val = data[key]
            if key == 'deadline': val = _parse_date(val)
            params.append(val)
    if not fields:
        return jsonify({'status': 'error', 'message':'수정할 값이 없습니다.'}), 400
    params.append(task_id)
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute(f"UPDATE Tasks SET {', '.join(fields)} WHERE id=%s", tuple(params))
            cur.execute("SELECT * FROM Tasks WHERE id = %s", (task_id,))
            updated_task = cur.fetchone()
        return jsonify(updated_task)
    finally:
        conn.close()

@app.route('/api/tasks/reorder', methods=['POST'])
def reorder_tasks():
    data = request.get_json() or {}
    ordered_ids = data.get('task_ids')
    if not ordered_ids:
        return jsonify({'status': 'error', 'message': 'task_ids가 필요합니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            update_data = [(i + 1, task_id) for i, task_id in enumerate(ordered_ids)]
            psycopg2.extras.execute_batch(cur, "UPDATE Tasks SET task_order=%s WHERE id=%s", update_data)
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/task/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Tasks WHERE id=%s", (task_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# =================================
# 6. 코멘트 (Comments) API
# =================================

@app.route('/api/project/<int:project_id>/comment', methods=['POST'])
def create_comment(project_id):
    data = request.get_json() or {}
    author_name = data.get('author_name')
    content = data.get('content')
    if not author_name or not content:
        return jsonify({'status':'error','message':'author_name, content 필수'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Comments (project_id, author_name, content) VALUES (%s,%s,%s) RETURNING *", (project_id, author_name, content))
            new_comment = cur.fetchone()
        return jsonify(new_comment), 201
    finally:
        conn.close()

@app.route('/api/comment/<int:comment_id>', methods=['PUT'])
def update_comment(comment_id):
    content = (request.get_json() or {}).get('content')
    if not content:
        return jsonify({'status': 'error', 'message': '내용이 필요합니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Comments SET content=%s WHERE id=%s RETURNING *", (content, comment_id))
            updated_comment = cur.fetchone()
        return jsonify(updated_comment)
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500
    finally:
        conn.close()

@app.route('/api/comment/<int:comment_id>', methods=['DELETE'])
def delete_comment(comment_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Comments WHERE id=%s", (comment_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

# =================================
# 7. 게시판 (Posts) API
# =================================

@app.route('/api/post', methods=['POST'])
def create_post():
    data = request.get_json() or {}
    required = ['title','content','user_id']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("INSERT INTO Posts (title, content, user_id) VALUES (%s,%s,%s) RETURNING id", (data['title'], data['content'], data['user_id']))
            post_id = cur.fetchone()['id']
            cur.execute("INSERT INTO PostReadStatus (user_id, post_id) VALUES (%s,%s) ON CONFLICT DO NOTHING", (data['user_id'], post_id))
            cur.execute("SELECT p.*, u.name as author_name FROM Posts p JOIN Users u ON p.user_id = u.id WHERE p.id = %s", (post_id,))
            new_post = cur.fetchone()
        return jsonify(new_post), 201
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['PUT'])
def update_post(post_id):
    data = request.get_json() or {}
    required = ['title','content']
    if any(k not in data for k in required):
        return jsonify({'status':'error','message':'필수 정보가 누락되었습니다.'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("UPDATE Posts SET title=%s, content=%s, updated_at=NOW() WHERE id=%s", (data['title'], data['content'], post_id))
            cur.execute("SELECT p.*, u.name as author_name FROM Posts p JOIN Users u ON p.user_id = u.id WHERE p.id = %s", (post_id,))
            updated_post = cur.fetchone()
        return jsonify(updated_post)
    finally:
        conn.close()

@app.route('/api/post/<int:post_id>', methods=['DELETE'])
def delete_post(post_id):
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("DELETE FROM Posts WHERE id=%s", (post_id,))
        return jsonify({'status':'success'})
    finally:
        conn.close()

@app.route('/api/posts/mark-as-read', methods=['POST'])
def mark_posts_as_read():
    user_id = (request.get_json() or {}).get('user_id')
    if not user_id:
        return jsonify({'status':'error','message':'user_id is required'}), 400
    conn = get_db_connection()
    try:
        with conn, conn.cursor() as cur:
            cur.execute("""
                INSERT INTO PostReadStatus (user_id, post_id)
                SELECT %s, p.id FROM Posts p
                WHERE NOT EXISTS (
                    SELECT 1 FROM PostReadStatus r WHERE r.post_id = p.id AND r.user_id = %s
                )
            """, (user_id, user_id))
        return jsonify({'status':'success'})
    finally:
        conn.close()

if __name__ == '__main__':
    app.run(debug=True)